name: Release

on:
  push:
    branches:
      - main

permissions:
  contents: write

env:
  CARGO_TERM_COLOR: always
  BIN_NAME: koi

jobs:
  # ‚îÄ‚îÄ Prepare ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  prepare:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.meta.outputs.version }}
      tag: ${{ steps.meta.outputs.tag }}
      description: ${{ steps.meta.outputs.description }}
    steps:
      - uses: actions/checkout@v4

      - name: Extract version metadata
        id: meta
        shell: bash
        run: |
          VERSION=$(grep -m1 '^version' Cargo.toml | sed 's/version = "\(.*\)"/\1/')
          TAG="v${VERSION}"
          DESCRIPTION=$(jq -r '.description // empty' version.json)
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "description=$DESCRIPTION" >> "$GITHUB_OUTPUT"
          echo "Tag: $TAG"
          echo "Version: $VERSION"
          echo "Description: $DESCRIPTION"

  # ‚îÄ‚îÄ Test ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - uses: Swatinem/rust-cache@v2
      - name: Test
        run: cargo test --locked

  # ‚îÄ‚îÄ Build ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  build:
    needs: [prepare, test]
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: x86_64-unknown-linux-musl
            os: ubuntu-latest
            use_cross: true
          - target: aarch64-unknown-linux-musl
            os: ubuntu-latest
            use_cross: true
          - target: x86_64-apple-darwin
            os: macos-latest
            use_cross: false
          - target: aarch64-apple-darwin
            os: macos-latest
            use_cross: false
          - target: x86_64-pc-windows-msvc
            os: windows-latest
            use_cross: false
          - target: aarch64-pc-windows-msvc
            os: windows-latest
            use_cross: false
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4

      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - uses: Swatinem/rust-cache@v2
        with:
          key: ${{ matrix.target }}

      - name: Install cross
        if: matrix.use_cross
        run: cargo install cross --locked

      - name: Build
        shell: bash
        run: |
          if [ "${{ matrix.use_cross }}" = "true" ]; then
            cross build --release --locked --target ${{ matrix.target }}
          else
            cargo build --release --locked --target ${{ matrix.target }}
          fi

      - name: Package
        shell: bash
        run: |
          VERSION="${{ needs.prepare.outputs.tag }}"
          TARGET="${{ matrix.target }}"
          ARCHIVE_DIR="${BIN_NAME}-${VERSION}-${TARGET}"
          mkdir "$ARCHIVE_DIR"

          # Copy binary
          BIN_SUFFIX=""
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            BIN_SUFFIX=".exe"
          fi
          cp "target/${TARGET}/release/${BIN_NAME}${BIN_SUFFIX}" "$ARCHIVE_DIR/"

          # Copy docs and licenses
          cp README.md "$ARCHIVE_DIR/" 2>/dev/null || true
          cp LICENSE* "$ARCHIVE_DIR/" 2>/dev/null || true

          # Create archive
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            7z a "${ARCHIVE_DIR}.zip" "$ARCHIVE_DIR"
            echo "ASSET=${ARCHIVE_DIR}.zip" >> "$GITHUB_ENV"
          else
            tar czf "${ARCHIVE_DIR}.tar.gz" "$ARCHIVE_DIR"
            echo "ASSET=${ARCHIVE_DIR}.tar.gz" >> "$GITHUB_ENV"
          fi

      - name: Checksum
        shell: bash
        run: |
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            sha256sum "${{ env.ASSET }}" > "${{ env.ASSET }}.sha256"
          else
            shasum -a 256 "${{ env.ASSET }}" > "${{ env.ASSET }}.sha256"
          fi
          cat "${{ env.ASSET }}.sha256"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-${{ matrix.target }}
          path: |
            ${{ env.ASSET }}
            ${{ env.ASSET }}.sha256

  # ‚îÄ‚îÄ Release ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  release:
    needs: [prepare, build]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          pattern: release-*
          merge-multiple: true

      - name: Generate release notes
        shell: bash
        run: |
          VERSION="${{ needs.prepare.outputs.tag }}"
          DESCRIPTION="${{ needs.prepare.outputs.description }}"

          # Read the template and substitute
          TEMPLATE=$(cat .github/release-template.md)
          NOTES="${TEMPLATE//\$\{VERSION\}/$VERSION}"
          NOTES="${NOTES//\$\{DESCRIPTION\}/$DESCRIPTION}"

          # Build checksums table
          CHECKSUMS=""
          for f in artifacts/*.sha256; do
            HASH=$(cut -d' ' -f1 "$f")
            FILE=$(basename "${f%.sha256}")
            CHECKSUMS="${CHECKSUMS}${HASH}  ${FILE}"$'\n'
          done
          NOTES="${NOTES//\$\{CHECKSUMS\}/$CHECKSUMS}"

          echo "$NOTES" > release-notes.md
          echo "--- Release notes ---"
          cat release-notes.md

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ needs.prepare.outputs.tag }}"
          # Clean slate: delete any existing release for this tag
          gh release delete "$TAG" --yes 2>/dev/null || true
          # Delete existing tag if present (so we can re-tag at current commit)
          git tag -d "$TAG" 2>/dev/null || true
          git push origin ":refs/tags/$TAG" 2>/dev/null || true
          # Create tag at current commit and release
          git tag "$TAG"
          git push origin "$TAG"
          gh release create "$TAG" \
            --title "$TAG" \
            --notes-file release-notes.md \
            artifacts/*

  # ‚îÄ‚îÄ Publish to crates.io ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  publish:
    needs: [test]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - uses: Swatinem/rust-cache@v2
      - name: Publish to crates.io
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
        run: |
          # crates.io rate limits (from rate_limiter.rs):
          #   PublishNew:    burst 5, refill 1 token per 10 min
          #   PublishUpdate: burst 30, refill 1 token per 1 min

          CRATES=(
            koi-common      # Layer 0: no internal deps
            koi-config      # Layer 1: depends on koi-common
            koi-crypto      # Layer 1
            koi-truststore  # Layer 1
            koi-mdns        # Layer 1
            koi-certmesh    # Layer 2: depends on layer 0-1
            koi-dns         # Layer 3: depends on layer 0-2
            koi-proxy       # Layer 3
            koi-health      # Layer 4: depends on layer 0-3
            koi-client      # Layer 5: depends on health + mdns
            koi-embedded    # Layer 6: depends on everything
            koi-net         # Layer 6
          )

          # ‚îÄ‚îÄ Phase 1: Inventory ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          echo "‚ïê‚ïê‚ïê Inventory ‚ïê‚ïê‚ïê"
          NEW_CRATES=()
          UPDATE_CRATES=()
          for crate in "${CRATES[@]}"; do
            status=$(curl -s -o /dev/null -w "%{http_code}" \
              -H "User-Agent: koi-ci (https://github.com/sylin-org/koi)" \
              "https://crates.io/api/v1/crates/${crate}")
            if [ "$status" = "200" ]; then
              UPDATE_CRATES+=("$crate")
            else
              NEW_CRATES+=("$crate")
            fi
          done

          echo "Updates (burst 30): ${UPDATE_CRATES[*]:-none}"
          echo "New     (burst 5):  ${NEW_CRATES[*]:-none}"
          echo ""

          NEW_TOTAL=${#NEW_CRATES[@]}
          if [ "$NEW_TOTAL" -gt 0 ]; then
            BATCHES=$(( (NEW_TOTAL + 4) / 5 ))
            WAIT_MIN=$(( (BATCHES - 1) * 10 ))
            echo "‚ö†Ô∏è  ${NEW_TOTAL} new crate(s) ‚Üí ${BATCHES} batch(es), ~${WAIT_MIN} min of rate-limit waits"
          else
            echo "‚úÖ All crates are updates ‚Äî no rate-limit waits needed"
          fi
          echo ""

          # ‚îÄ‚îÄ Phase 2: Publish ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          echo "‚ïê‚ïê‚ïê Publishing ‚ïê‚ïê‚ïê"
          NEW_COUNT=0
          NEW_BURST=5

          for crate in "${CRATES[@]}"; do
            # Check if this crate is new (not in UPDATE_CRATES)
            IS_UPDATE=false
            for u in "${UPDATE_CRATES[@]}"; do
              if [ "$u" = "$crate" ]; then
                IS_UPDATE=true
                break
              fi
            done

            if [ "$IS_UPDATE" = true ]; then
              echo "üì¶ ${crate}: update"
            else
              NEW_COUNT=$((NEW_COUNT + 1))
              echo "üÜï ${crate}: new (${NEW_COUNT}/${NEW_BURST} tokens)"
              if [ "$NEW_COUNT" -ge "$NEW_BURST" ]; then
                echo "‚è≥ New-crate bucket exhausted. Waiting 10 min for refill..."
                sleep 600
                NEW_COUNT=0
              fi
            fi

            cargo publish -p "${crate}" --locked 2>&1 | tee /tmp/publish_output.txt || {
              if grep -q "already exists" /tmp/publish_output.txt; then
                echo "‚è≠Ô∏è  ${crate}: version already published, skipping"
              elif grep -q "429" /tmp/publish_output.txt; then
                # Extract "try again after <timestamp>" and wait until then
                RETRY_AFTER=$(grep -oP 'try again after \K[^o]+' /tmp/publish_output.txt | head -1 | xargs)
                if [ -n "$RETRY_AFTER" ]; then
                  RETRY_EPOCH=$(date -d "$RETRY_AFTER" +%s 2>/dev/null || echo "")
                  NOW_EPOCH=$(date +%s)
                  if [ -n "$RETRY_EPOCH" ] && [ "$RETRY_EPOCH" -gt "$NOW_EPOCH" ]; then
                    WAIT_SECS=$(( RETRY_EPOCH - NOW_EPOCH + 5 ))
                    echo "‚è≥ Rate limited. Waiting ${WAIT_SECS}s until ${RETRY_AFTER}..."
                    sleep "$WAIT_SECS"
                  else
                    echo "‚è≥ Rate limited. Waiting 10 min (could not parse timestamp)..."
                    sleep 600
                  fi
                else
                  echo "‚è≥ Rate limited. Waiting 10 min (no timestamp found)..."
                  sleep 600
                fi
                # Retry the publish after waiting
                echo "üîÑ Retrying ${crate}..."
                cargo publish -p "${crate}" --locked
              else
                echo "‚ùå ${crate}: publish failed"
                cat /tmp/publish_output.txt
                exit 1
              fi
            }
            echo "‚úÖ ${crate} done"

            # Brief pause for index propagation
            sleep 20
          done

          echo ""
          echo "‚ïê‚ïê‚ïê All ${#CRATES[@]} crates published ‚ïê‚ïê‚ïê"
